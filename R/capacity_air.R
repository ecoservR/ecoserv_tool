########################################
### Air purification capacity model  ###
### for EcoservR tool                ###
### Sandra Angers-Blondin            ###
### 09 Dec 2020                      ###
########################################

### NOTES: this is modified from the original Ecoserv-GIS to reflect the changes made by Natural Capital Solutions.
## They include:
# increasing buffer from 10 m to 100 m
# decreasing functional threshold from 500m2 to 100 m2

#' Air Purification Capacity Model
#'
#' Runs the air purification ecosystem service model, generating capacity scores based on the ability of vegetation to trap particulate matter.

#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attribute HabCode_B.
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape. For best results this shape should be smaller than the basemap (which should be buffered by typically 300 m - 1km to avoid edge effects).
#' @param res Desired resolution of the raster. Default is 5 m. Range recommended is 5-10m.
#' @param buffer Distance (m) from habitats to define areas in which the service occurs. Default is 100m.
#' @param short Radius (m) for focal statistics at short range. Default is 20 m.
#' @param local Radius (m) for focal statistics at local range (maximum distance for effectiveness). Default is 100 m.
#' @param threshold Size (m2) below which an isolated patch is not considered able to provide the service. Default is 100 m2.
#' @param use_hedges Use a separate hedgerow layer? Default FALSE, see clean_hedgerows() for producing a model-ready hedge layer.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "services_". Do not use this argument unless you need to save the outputs somewhere else.
#' @return Two rasters with capacity scores: one with raw scores (arbitrary units), and one rescaled 0-100 (where 100 is maximum capacity for the area).
#' @export
#'
capacity_air_purif <- function(x = parent.frame()$mm,
                               studyArea = parent.frame()$studyArea,
                               res = 5,
                         short = 20, local = 100,
                         buffer = 100,
                         threshold = 100,
                         use_hedges = FALSE,
                         projectLog = parent.frame()$projectLog,
                         runtitle = parent.frame()$runtitle,
                         save = NULL
){

   timeA <- Sys.time() # start time

   # Create output directory automatically if doesn't already exist
   if (is.null(save)){

      save <- file.path(projectLog$projpath,
                        paste0("services_", runtitle))

      if (!dir.exists(save)){
         dir.create(save)
      }
   } else {
      # if user specified their own save directory we check that it's ok
      if(!dir.exists(save) | file.access(save, 2) != 0){
         stop("Save directory doesn't exist, or you don't have permission to write to it.")}
   }

   # Create a temp directory for scratch files

   scratch <- file.path(projectLog$projpath,
                        "ecoservR_scratch")

   if(!dir.exists(scratch)){
      dir.create(scratch)
   }


   # if mm is stored in list, combine all before proceeding
   if (isTRUE(class(x) == "list")){
      message("Recombining basemap tiles")
      x <- do.call(rbind, x) %>% sf::st_as_sf()
      # NOT using rbindlist here because only keeps the extent of the first tile
   }

   studyArea <- sf::st_zm(studyArea, drop=TRUE) # make sure study area doesn't have Z dim

   ### Check and import hedgerows ---
   if (use_hedges){

      if (!file.exists(projectLog$clean_hedges)){stop("use_hedges is TRUE but no file found. Check projectLog$clean_hedges")}

      hedges <- readRDS(projectLog$clean_hedges) %>%
         dplyr::mutate(HabCode_B = 'J21') %>%
         merge(hab_lookup[c("Ph1code", "AirPurScore")], by.x = 'HabCode_B', by.y = 'Ph1code', all.x = TRUE)

      message("Loaded hedges from ", projectLog$clean_hedges)

   }


   ### Merge the lookup table -----

   x <- merge(x, hab_lookup, by.x = "HabCode_B", by.y = "Ph1code", all.x = TRUE)

   x <- x[c("HabCode_B", "AirPurScore")] # keep only required columns


   ### Create raster template with same properties as mastermap -----

   r <- raster::raster()  # create empty raster
   raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding datum to preserve CRS
   raster::extent(r) <- raster::extent(x)  # set same extent as the shapefile
   raster::res(r) <- res  # set resolution


   ### Rasterize -----

   ### Transfer air pur scores into a raster

   x <- x %>%
      dplyr::filter(AirPurScore > 0) %>% # keep only scores greater than 0
      checkgeometry(., "POLYGON")


   # Raster of air purification score
   air_r <- raster::writeRaster(
      fasterize::fasterize(x, r, field = "AirPurScore", background = NA),
      filename = file.path(scratch, "airpur_cap"),
      overwrite = TRUE  # because it's a temporary file we don't mind overwriting it if it exists
   )

   ### Create a distance mask (range within which we calculate scores)

   # We don't need x anymore, except for buffering to create mask around the capacity areas
   x <- x %>% sf::st_buffer(buffer) %>% checkgeometry(., "POLYGON")

   if (use_hedges){

      # Create raster of hedge scores
      hedges_r <- raster::writeRaster(
         fasterize::fasterize(hedges, r, field = "AirPurScore", background = NA),
         filename = file.path(scratch, "hedges_air_purif"), overwrite = TRUE)

      # Overwrite the basemap scores in places with hedges
      air_r <- raster::mask(air_r, hedges_r, inverse = T) %>%
         raster::cover(hedges_r)

      # Add hedges to mask
      hedges <- sf::st_geometry(hedges) %>%
         sf::st_buffer(buffer) %>% sf::st_as_sf() %>%
         checkgeometry(., "POLYGON")
      x <- rbind(x, hedges)
   }



   airmask <- fasterize::fasterize(x, r, field = NULL, background = NA)



   ### Focal statistics ----

   message("Calculating scores at short range.")
   air_short <- focalScore(air_r, radius = short, type = "sum")

   message("Calculating scores at local scale.")
   air_long <- focalScore(air_r, radius = local, type = "sum")



   ### Calculate score -----

   air_score <- raster::writeRaster(sum(air_short, air_long, na.rm = TRUE),
                                    filename = file.path(scratch, "airpur_score"),
                                    overwrite = TRUE)

   rm(air_short, air_long) # remove previous rasters

   ## Mask by distance mask

   air_score <- raster::mask(air_score, airmask)


   ### Create functional threshold mask ----
   message("Applying functional threshold.")

   # The function and notes on how it works can be found in the fun_spatial script

   # This function will create a mask raster based on patch statistics, removing all patches smaller than the threshold. The porportion allows for a small number of pixels in the neighbourhood to have a low score as it is hardly ever uniformly 0.

   air_score <- raster::writeRaster(
      functionalMask(air_score,  # the score raster we apply the function to
                     local = local,  # the local (wide) search radius set previously
                     res = res,   # the resolution of the raster set previously
                     proportion = 0.10,  # proportion of cells in the search circle which can have a low score (10) without being considered to contribute to the service
                     threshold = threshold)  # the size threshold set previously
      , filename = file.path(scratch, "airpur_score"),
      overwrite = TRUE
   )

   message("Saving final and standardised scores.")
   ### Clip to study area and save final file

   final <- raster::writeRaster(
      raster::mask(air_score, studyArea),
      filename = file.path(save,
                           paste(projectLog$title, runtitle, "air_purification_capacity.tif", sep="_")),
      overwrite = TRUE
   )
   rm(air_score)

   ### Also create a standardised version

   maxval <- max(raster::values(final), na.rm = TRUE)

   final_scaled <- raster::writeRaster(
      final/maxval*100,  # rescale from 0-100
      filename = file.path(save, paste(projectLog$title, runtitle, "air_purification_capacity_rescaled.tif", sep="_")),
      overwrite = TRUE  # perhaps not desirable but for now prevents error messages
   )


   timeB <- Sys.time() # stop time

   # write performance to log
   projectLog$performance[["cap_air"]] <- as.numeric(difftime(
      timeB, timeA, units="mins"
   ))


   updateProjectLog(projectLog) # save revised log


   # Delete all the stuff we don't need anymore

   on.exit({
      rm(r, final, final_scaled, maxval)
      cleanUp(scratch)
      message("Air purification capacity model finished. Process took ", round(difftime(timeB, timeA, units = "mins"), digits = 1), " minutes. Please check output folder for your maps.")
   })

   return({
      ## returns the objects in the global environment
      invisible({
         projectLog <<- projectLog
      })
   })


}
