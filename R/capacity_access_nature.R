#############################################
### Access to nature capacity model       ###
### for EcoservR tool                     ###
### Sandra Angers-Blondin                 ###
### 18 Dec 2020                           ###
#############################################

### NOTES
## Eventually all the extra datasets could be built into the tool.

#' Access to Nature Capacity Model
#'
#' Runs the access to nature ecosystem service model, generating capacity scores based on perceived "naturalness" of the habitats and their public accessibility. Calls external datasets which must be supplied by user: Public Rights of Way, CRoW, Local and National Nature Reserves.

#' @param x A basemap, in a list of sf tiles or as one sf object. Must have attributes HabCode_B, GI (type of green infrastructure), and GIpublic (Private/Restricted/Public access).
#' @param studyArea The boundaries of the site, as one sf object. The final raster will be masked to this shape. For best results this shape should be smaller than the basemap (which should be buffered by typically 300 m - 1km to avoid edge effects).
#' @param prow Path to folder containing Public Rights of Way data for your study area (shapefile or geopackage).
#' @param crow Path to folder containing CRoW data (Open Country and Registered Common Land) for your study area (shapefile or geopackage).
#' @param lnr Path to folder containing Local Nature Reserves boundaries for your study area (shapefile or geopackage).
#' @param nnr Path to folder containing National Nature Reserves boundaries for your study area (shapefile or geopackage).
#' @param res Desired resolution of the raster. Default is 5 m. Range recommended is 5-10m.
#' @param local Radius (m) for focal statistics at local range (maximum distance for effectiveness). Default is 100 m.
#' @param threshold Size (m2) below which an isolated patch is not considered able to provide the service. Default is 100 m2.
#' @param projectLog The RDS project log file generated by the wizard app and containing all file paths to data inputs and model parameters
#' @param runtitle A customised title you can give a specific model run, which will be appended to your project title in the outputs. If comparing a basemap to an intervention map, we recommend using "pre" and "post", or a short description of the interventions, e.g. "baseline" vs "tree planting".
#' @param save Path to folder where outputs will be saved. By default a folder will be created using your chosen run title, prefixed by "services_". Do not use this argument unless you need to save the outputs somewhere else.
#' @return Two rasters with capacity scores: one with raw scores (arbitrary units), and one rescaled 0-100 (where 100 is maximum capacity for the area).
#' @export
#'
capacity_access_nature <- function(x = parent.frame()$mm,
                                   studyArea = parent.frame()$studyArea,
                               prow,
                               crow,
                               lnr,
                               nnr,
                               res = 5,
                               local = 300,
                               threshold = 500,
                               projectLog = parent.frame()$projectLog,
                               runtitle = parent.frame()$runtitle,
                               save = NULL
){

   timeA <- Sys.time() # start time

   # Create output directory automatically if doesn't already exist
   if (is.null(save)){

      save <- file.path(projectLog$projpath,
                        paste0("services_", runtitle))

      if (!dir.exists(save)){
         dir.create(save)
      }
   } else {
      # if user specified their own save directory we check that it's ok
      if(!dir.exists(save) | file.access(save, 2) != 0){
         stop("Save directory doesn't exist, or you don't have permission to write to it.")}
   }

   # Create a temp directory for scratch files

   scratch <- file.path(projectLog$projpath,
                        "ecoservR_scratch")

   if(!dir.exists(scratch)){
      dir.create(scratch)
   }

   studyArea <- sf::st_zm(studyArea, drop=TRUE) # make sure study area doesn't have Z dim

   # if mm is stored in list, combine all before proceeding
   if (isTRUE(class(x) == "list")){
      message("Recombining basemap tiles")
      x <- do.call(rbind, x) %>% sf::st_as_sf()
      # NOT using rbindlist here because only keeps the extent of the first tile
   }

   x$HabClass <- NULL
   x$HabBroad <- NULL  # if the attributes are already present in basemap remove them, as they get joined with lookup

   ### Merge the lookup table -----

   x <- merge(x, hab_lookup, by.x = "HabCode_B", by.y = "Ph1code", all.x = TRUE)

   # removed dependencies on group and GI because intervention maps don't have updated values
   x <- x[c("HabCode_B", "HabClass", "HabBroad",
            #"Group",
            #"GI",
            "GIpublic", "Naturalness")] # keep only required columns


   ### Create raster template with same properties as mastermap -----

   r <- raster::raster()  # create empty raster
   raster::crs(r) <- sp::CRS(SRS_string = "EPSG:27700") # hard-coding datum to preserve CRS
   raster::extent(r) <- raster::extent(x)  # set same extent as the shapefile
   raster::res(r) <- res  # set resolution

   message("Importing public access datasets...")
   ### Import the public access datasets ----

   # Buffer the study area so we don't lose anything at the edges

   SAbuffer <- sf::st_buffer(studyArea, local + 100) %>% sf::st_transform(27700)
   # The builder function loads all files if many present, and strips them of all columns but geometry

   prow <- importDesignatedAreas(path = prow, studyArea = SAbuffer, dataset = "PROW")

   crow <- importDesignatedAreas(path = crow, studyArea = SAbuffer, dataset = "CRoW")

   lnr <- importDesignatedAreas(path = lnr, studyArea = SAbuffer, dataset = "LNR")

   nnr <- importDesignatedAreas(path = nnr, studyArea = SAbuffer, dataset = "NNR")


   ### Process and merge the access layers ---

   # PROW is buffered and converted to polygon, others converted to be all same type

   if (!is.null(prow)){
      prow <- sf::st_buffer(prow, 20)   # buffer around path which is what people experience

      prow <- checkgeometry(prow, "POLYGON") # check and cast to polygon
      prow <- checkcrs(prow, 27700)  # check and reproject if needed

   }


   if (!is.null(crow)){
      crow <- checkgeometry(crow, "POLYGON")
      crow <- checkcrs(crow, 27700)
   }

   if (!is.null(lnr)){
      lnr <- checkgeometry(lnr, "POLYGON")
      lnr <- checkcrs(lnr, 27700)
   }

   if (!is.null(nnr)){
      nnr <- checkgeometry(nnr, "POLYGON")
      nnr <- checkcrs(nnr, 27700)
   }

   ## Make a list of access layers, drop empty, and bind

   access <- list(prow, crow, nnr, lnr)
   access <- access[sapply(access, function(x) length(x) > 0)]  # drop empty elements

   # drop Z dimension
   access <- lapply(access, function(x) sf::st_zm(x, drop = TRUE))

   access <- do.call(rbind, access)

   rm(prow, crow, lnr, nnr)


   ### Also extract paths from basemap
   message("Extracting public pavements from the basemap")

   sidewalk <- dplyr::filter(x, HabCode_B == "J52") %>%   # pavements are extracted
      sf::st_buffer(20) %>%  # buffer applied
      sf::st_union() %>%  # union to remove overlap
      sf::st_as_sf()  # put back in sf format, with only geometry column

   sidewalk <- checkgeometry(sidewalk, "POLYGON")

   ## Ideally would also use VectorMap to remove roadside along major roads....



   message("Extracting public greenspace from the basemap")
   ### Create the rest of the access objects from basemap

   GI_access <- dplyr::filter(x, GIpublic %in% c("Public", "Restricted"))   # keep only publicly accessible greenspaces
   GI_access <- sf::st_geometry(GI_access) %>%   # keep only geometry column
      sf::st_as_sf()
   GI_access <- checkgeometry(GI_access, "POLYGON")




   ### Create the workflow for beaches (at a later point) -----








   ### Create full access layer that will be used to clip the map ----
   message("Generating accessibility mask (this may take a while)")
   accessmask <- rbind(access, GI_access, sidewalk) %>%
      sf::st_union() %>%  # union to remove overlap between layers
      sf::st_sf()

   rm(GI_access, sidewalk, access)

   accessmask <- checkgeometry(accessmask, "POLYGON")  # make sure we have poly format


   ### Create full GI subset that will be masked by access ----

   # All greenspace (selection before June 2021)
   #green_all <- dplyr::filter(x, GI != "Not Greenspace")

   # All greenspace, now without previous dependency on the GI attribute
   # (which may not be available in intervention polygons)

   green_all <- dplyr::filter(x,
                              !HabBroad %in% c(
      "Artificial exposure / waste",
      "Built up areas",
      "Roads", "Railway", "Pavement", "Path"
   ),
      !HabCode_B %in% c("Unclassified, not greenspace",
                        "Unclassified, area in development"))



   ### Rasterize -----

   # Rasterize the access mask for much faster processing
   accessmask_r <- raster::writeRaster(
      fasterize::fasterize(accessmask, r, field = NULL, background = NA),
      filename = file.path(scratch, "accessnature_mask"),
      overwrite = TRUE  # because it's a temporary file we don't mind overwriting it if it exists
   )
   rm(accessmask)

   # Rasterize the greenspace on Naturalness

   green_all_r <- raster::writeRaster(
      fasterize::fasterize(green_all, r, field = "Naturalness", background = NA),
      filename = file.path(scratch, "accessnature_allgreen"),
      overwrite = TRUE  # because it's a temporary file we don't mind overwriting it if it exists
   )

   # Mask non-accessible greenspaces

   # HACK... crs shifted a tiny fraction during a previous step so resetting:
   raster::crs(accessmask_r) <- raster::crs(green_all_r)

   access_r <- raster::writeRaster(
      raster::mask(green_all_r, accessmask_r),   # mask all greenspace by access layer
      filename = file.path(scratch, "accessnature_accessgreen"),
      overwrite = TRUE  # because it's a temporary file we don't mind overwriting it if it exists
   )


   ### Extract threshold -----

   # Extract by mask is used to create a dataset above a user-defined threshold of greenspace sites... ???
   # skipped this one - functional threshold is applied later



   ### Multiply raster by 10 to get scores ----

   score_all_r <- raster::writeRaster(
      green_all_r * 10,
      filename = file.path(scratch, "accessnature_allgreen"),
      overwrite = TRUE
   )


   score_access_r <- raster::writeRaster(
      access_r * 10,
      filename = file.path(scratch, "accessnature_accessgreen"),
      overwrite = TRUE
   )

   rm(green_all_r, access_r)

   ### Focal statistics ----

   message("Calculating scores")

   score_all_r <- focalScore(score_all_r, radius = local, type = "sum")
   score_access_r <- focalScore(score_access_r, radius = local, type = "sum")

   ### OLD FOCAL STATS
   # Create weight matrices based on the search radius for focal stats
   # (automatically considers the res of the raster to calculate distance)

   # w_short <- raster::focalWeight(r, local, "circle")   # search window for the short dist, gives weighted indices that allow to calculate a mean
   # w_short[w_short > 0] <- 1               # replacing weights by 1 (we want full sum)
   #
   # # Raster of scores, averaged at local scale
   # score_all_r <- raster::focal(score_all_r, w = w_short, na.rm = TRUE,
   #                      filename = file.path(scratch, "accessnature_allscore"),
   #                      overwrite = TRUE)  # the full nature raster
   #
   # score_access_r <- raster::focal(score_access_r, w = w_short, na.rm = TRUE,
   #                         filename = file.path(scratch, "accessnature_accessscore"),
   #                         overwrite = TRUE)  # the accessible nature raster



   ### Create functional threshold mask ----
   message("Applying functional threshold mask")

   # This function will create a mask raster based on patch statistics, removing all patches smaller than the threshold.

   # All greenspace raster
   score_all_r <- raster::writeRaster(
      functionalMask(score_all_r ,    # the score raster we apply the function to
                     local = local,  # the local search radius set previously
                     res = res,       # the resolution of the raster set previously
                     proportion = 0.05,  # proportion of cells in the search circle which can have a score of 10 without being considered to contribute to the service
                     threshold = threshold)  # the size threshold set previously
      , filename = file.path(scratch, "accessnature_allscore"),
      overwrite = TRUE
   )


   # Accessible greenspace raster
   score_access_r <- raster::writeRaster(
      functionalMask(score_access_r ,    # the score raster we apply the function to
                     local = local,  # the local search radius set previously
                     res = res,       # the resolution of the raster set previously
                     proportion = 0.05,  # proportion of cells in the search circle which can have a score of 10 without being considered to contribute to the service
                     threshold = threshold)  # the size threshold set previously
      , filename = file.path(scratch, "accessnature_accessscore"),
      overwrite = TRUE
   )


   ### Clip to study area and save final files
   message("Saving final and standardised scores.")

   final_all <- raster::writeRaster(
      raster::mask(score_all_r, studyArea),
      filename = file.path(save, paste(projectLog$title, runtitle, "access_nature_all_capacity.tif", sep="_")),
      overwrite = TRUE
   )

   final_access <- raster::writeRaster(
      raster::mask(score_access_r, studyArea),
      filename = file.path(save, paste(projectLog$title, runtitle, "access_nature_accessOnly_capacity.tif", sep="_")),
      overwrite = TRUE
   )

   ### Also create a standardised version
   maxvalall <- max(raster::values(final_all), na.rm = TRUE) # max value of raster for standardising
   maxvalacc <- max(raster::values(final_access), na.rm = TRUE)

   final_all_scaled <- raster::writeRaster(
      final_all/maxvalall*100,  # rescale from 0-100
      filename = file.path(save, paste(projectLog$title, runtitle, "access_nature_all_capacity_rescaled.tif", sep="_")),
      overwrite = TRUE  # perhaps not desirable but for now prevents error messages
   )

   final_access_scaled <- raster::writeRaster(
      final_access/maxvalacc*100,  # rescale from 0-100
      filename = file.path(save, paste(projectLog$title, runtitle, "access_nature_accessOnly_capacity_rescaled.tif", sep="_")),
      overwrite = TRUE  # perhaps not desirable but for now prevents error messages
   )

   timeB <- Sys.time() # stop time

   # write performance to log
   projectLog$performance[["cap_access"]] <- as.numeric(difftime(
      timeB, timeA, units="mins"
   ))


   updateProjectLog(projectLog) # save revised log



   # Delete all the stuff we don't need anymore

   on.exit({
      rm(r, final_access, final_access_scaled, final_all, final_all_scaled, maxvalall, maxvalacc)
      cleanUp(scratch)
      message("Access to nature capacity model finished. Process took ", round(difftime(timeB, timeA, units = "mins"), digits = 1), " minutes. Please check output folder for your maps.")
   })

   return({
      ## returns the objects in the global environment
      invisible({
         projectLog <<- projectLog
      })
   })



}
